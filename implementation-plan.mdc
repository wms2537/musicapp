---
description:
globs:
alwaysApply: false
---
# Implementation Plan for MusicApp Features

## Feature Checklist

- [x] 1. 调节上一曲和下一曲 (Previous/Next Track) (15%)
- [x] 2. 多种倍速播放【0.5，1，1.5，2 倍速】(Playback Speed Control) (25%)
- [x] 3. 快进快退【快进 10s，快退 10s】(Seek Forward/Backward) (20%)
- [x] 4. 暂停继续 (Pause/Resume) (10%)
- [x] 5. 日志输出 (Logging Output) (15%)

## Detailed Steps

### 1. Pause/Resume Functionality
- Add a global state variable `playback_paused`.
- Modify the main loop to check this state.
- Use `snd_pcm_pause()` to pause and resume ALSA playback.
- Assign a key (e.g., 'p') for toggling pause/resume.
- *Done*
  - Summary: Added `playback_paused` global boolean. Modified the main playback loop to check for 'p' key input. Used `snd_pcm_pause(pcm_handle, 1)` for pause and `snd_pcm_pause(pcm_handle, 0)` for resume. Added a short `usleep` during pause to reduce CPU load.

### 2. Seek Forward/Backward Functionality
- Define seek duration (e.g., 10 seconds).
- Add key bindings (e.g., 'f' for forward, 'b' for backward).
- Implement `fseek()` on the music file pointer `fp`.
- Calculate seek offset using `wav_header.byte_rate`.
- Consider ALSA buffer state after seeking (e.g., `snd_pcm_drop()` or `snd_pcm_prepare()`).
- *Done*
  - Summary: Added handling for 'f' (forward) and 'b' (backward) keys. Used `fseek(fp, offset, SEEK_CUR)` with `offset = +/- 10 * wav_header.byte_rate`. For backward seek, if it fails (e.g., trying to seek before file start), it seeks to the beginning of audio data (after WAV header). Noted that ALSA buffer might need reset for smoother seeking, but this is left as an optional improvement for now.

### 3. Previous/Next Track Functionality
- Modify `main()` to accept a list of music files or a playlist file.
- Store the list of tracks and the current track index.
- Implement functions `play_next_track()` and `play_previous_track()`.
- These functions will close the current file, open the new file, and re-initialize playback if necessary.
- Add key bindings (e.g., 'N' for next, 'P' for previous - distinct from 'p' for pause).
- *Done*
  - Summary: Modified `main` to accept multiple filenames as non-option arguments. Added `music_files` array, `num_music_files`, `current_track_idx` globals. Created `load_track()` to handle opening new files. Implemented '.' (next) and ',' (previous) key controls. Added auto-play to the next track upon current track completion. The `-m` option is now deprecated. Memory for `music_files` is allocated and freed. Noted that robust ALSA re-initialization between tracks with different audio parameters might be needed.

### 4. Playback Speed Control
- Research ALSA capabilities for playback speed adjustment (e.g., `snd_pcm_sw_params_set_rate_resample` or software resampling).
- Add a global variable for current speed multiplier (0.5, 1.0, 1.5, 2.0).
- Add key bindings to cycle through speeds.
- Implement changes to ALSA parameters or data processing pipeline. This might involve recalculating buffer sizes or sample rates dynamically.
- *Done - Initial simple version (changes pitch)*
  - Summary: Implemented playback speed control for factors 0.5x, 1.0x, 1.5x, and 2.0x using '[' and ']' keys. The core logic involves software resampling (sample duplication/dropping) of the audio data from the input buffer (`buff`) into a temporary dynamically allocated buffer (`buffer_for_alsa`) before sending it to `snd_pcm_writei`. The amount of data read from the file per iteration remains the same, but the data written to ALSA is adjusted to achieve the desired speed. Error handling for memory allocation of the temporary buffer is included, with a fallback to normal speed for the current chunk if allocation fails. Logging calls were updated to use `app_log`.

**Enhancement: Pitch-Preserving Playback Speed Control (e.g., using WSOLA)**
- **Status**: In Progress
- **Details**: Replace the current simple resampling with an algorithm that preserves pitch while changing speed. WSOLA (Waveform Similarity-based Overlap-Add) or a similar time-domain technique will be targeted.

  1.  **Algorithm Research & Design Finalization**:
      *   Thoroughly review WSOLA principles and its variants.
      *   Define key parameters: analysis frame size (e.g., 20-40ms), synthesis frame size (derived from speed factor), overlap length, and search window for similarity.
            *   Initial parameters:
                *   `ANALYSIS_FRAME_SIZE_MS` (e.g., 30ms)
                *   `OVERLAP_PERCENTAGE` (e.g., 50%-75%)
                *   `SEARCH_WINDOW_MS` (e.g., +/- 10ms relative to ideal next segment)
                *   Derived sample counts will depend on `sample_rate`.
      *   Consider requirements for different audio sample formats (e.g., S16_LE).
      *   Status: Partially Done
      *   Summary: Initial WSOLA parameters identified. Key elements include analysis frame size, overlap percentage, and search window size. These will determine buffer requirements and processing steps. The algorithm will operate on S16_LE samples.

  2.  **Implement Core WSOLA Components**:
      *   **Windowing Function**: Implement a suitable window (e.g., Hanning window). `W(n) = 0.5 * (1 - cos(2 * PI * n / (M-1)))` where M is window length.
          *   Status: Done
          *   Summary: Implemented `generate_hanning_window` (float) and `convert_float_window_to_q15` (short) helpers in `MusicApp.c`. The Q15 Hanning window is stored in `WSOLA_State` during `wsola_init`.
      *   **Input Buffer Management**: Logic to feed audio frames into the WSOLA process.
          *   Status: Pending (Part of `wsola_process`)
          *   Summary:
      *   **Similarity Detection**: Function to find the best matching segment in the input signal for overlap-add, typically using cross-correlation or a sum of squared differences within a defined search area.
          *   Status: Pending (Helper for `wsola_process`, e.g., `find_best_match_segment` using `calculate_normalized_cross_correlation`)
          *   Summary:
      *   **Overlap-Add (OLA)**: Mechanism to combine (add) overlapping, windowed segments of audio to produce the output stream.
          *   Status: Pending (Part of `wsola_process`)
          *   Summary:
      *   **Output Buffer Management**: Collect the time-scaled audio.
          *   Status: Pending (Part of `wsola_process`)
          *   Summary:

  3.  **Data Structures for WSOLA State**:
      *   Define and implement structures to hold the state required for the WSOLA algorithm between processing blocks (e.g., previous frame data, history for overlap).
      *   Example: `typedef struct { short* previous_frame; int prev_frame_size; ... } WSOLA_State;`
            *   Initial structure proposal:
                ```c
                // In const.h or MusicApp.c
                // #define MAX_FRAME_SAMPLES 2048 // Example based on 48kHz, 40ms
                typedef struct {
                    int sample_rate;
                    int num_channels; // Initially 1 for simplicity, then extend
                    double current_speed_factor;

                    int analysis_frame_samples; // N
                    int overlap_samples;        // N_o
                    int synthesis_hop_samples;  // H_s = N - N_o (output step at 1x)
                    int analysis_hop_samples;   // H_a = N - N_o (input step at 1x)
                    int search_window_samples;  // S_w

                    short* analysis_window_function; // Precomputed Hanning/Hamming window
                    
                    // Ring buffer for input audio
                    short* input_buffer_ring;
                    int input_buffer_size;
                    int input_buffer_write_pos;
                    int input_buffer_read_pos;
                    int input_buffer_content;

                    // Buffer for storing the tail of the last synthesized frame for OLA
                    short* output_overlap_add_buffer;
                    int output_overlap_add_size; // Should be == overlap_samples

                    long long total_input_samples_processed;
                    long long total_output_samples_generated;
                } WSOLA_State;
                ```
      *   Status: Done
      *   Summary: Proposed a `WSOLA_State` structure to hold configuration (sample rate, speed factor), derived parameters (frame sizes, hop sizes), precomputed window, input ring buffer, and output overlap buffer. This structure will be central to the WSOLA implementation. Implemented `wsola_init` to allocate and initialize this state, and `wsola_destroy` to free it.

  4.  **Integration into `MusicApp.c`**:
      *   Develop a primary function, e.g., `int process_audio_wsola(WSOLA_State* state, const short* input_buffer, int num_input_samples, double speed_factor, short* output_buffer, int max_output_samples)`.
      *   Modify the main audio processing loop in `MusicApp.c`. Instead of simple sample duplication/dropping, audio chunks will be fed into `process_audio_wsola`.
      *   The output from WSOLA will then be sent to ALSA. This involves careful management of buffer sizes for both input to WSOLA and output to ALSA, as the number of output samples will vary based on the speed factor.
      *   Handle S16_LE format specifically for now. The `buff` (unsigned char) will need to be interpreted as `short` for processing.
      *   Status: Pending
      *   Summary:

  5.  **Testing and Quality Tuning**:
      *   Test with various audio files (music, speech) and all speed factors (0.5x, 1.5x, 2.0x).
      *   Tune WSOLA parameters (frame sizes, overlap, search window) to minimize artifacts (e.g., phasing, choppiness) and achieve the best possible audio quality.
      *   Profile CPU usage to ensure real-time performance is feasible.
      *   Status: Pending
      *   Summary:

  6.  **Update Documentation (README.md)**:
      *   Reflect that playback speed control now preserves pitch.
      *   Mention the algorithm used (e.g., WSOLA-based).
      *   Status: Pending
      *   Summary:

### 5. Logging Output
- Review existing `printf` statements.
- Enhance logging for new features (state changes, errors, actions).
- Consider adding a log level or a way to toggle verbose logging if needed.
- If complex, consider writing logs to a file.
- *Done*
  - Summary: Standardized logging to use the `app_log` function throughout the application, including for the newly implemented playback speed functionality and for previously modified features. This provides consistent log formatting with timestamps and log types (INFO, ERROR, WARNING). Replaced direct `fprintf(stderr, ...)` and `printf(...)` calls for logging purposes with `app_log`.

### General
- Update README.md with new features and controls.
- *Done*
  - Summary: Created a `README.md` file. It includes sections for Features, Compilation, Usage (command-line options and interactive controls), Dependencies, and Known Issues/Future Work. It highlights that playback speed audio processing is not yet implemented.
- Ensure error handling is robust for all new functionalities.
- *Partially Done*
  - Summary: Basic error handling (e.g., for file operations, memory allocation, ALSA calls) exists. Some new error messages were added. However, a comprehensive review and enhancement of error handling across all new features, especially for edge cases and recovery, would be a larger task and is considered partially addressed by the logging improvements and specific checks added.

# Implementation Plan

This document tracks the implementation of features and major changes in the MusicApp project.

## Feature: Playback Speed Control

-   **Status**: In Progress
-   **Details**: Implement variable playback speed for audio files.
    -   Allow users to increase or decrease playback speed using '[' and ']' keys.
    -   Modify audio processing loop to resample audio data based on selected speed factor.

## Equalizer Feature (FIR Filter)

1.  **Define FIR Filter Structures and Coefficients**:
    *   Define a structure for FIR filter parameters (coefficients, length).
    *   Define at least three sets of FIR coefficients for different equalizer modes (e.g., Normal/Flat, Bass Boost, Treble Boost). This will likely be in `const.h`.
    *   Status: Done
    *   Summary: Added `FIRFilter` typedef and `MAX_FIR_TAPS` to `const.h`. Defined `FIR_NORMAL`, `FIR_BASS_BOOST`, and `FIR_TREBLE_BOOST` with placeholder coefficients.

2.  **Implement FIR Filter Application Function**:
    *   Create a function `apply_fir_filter(short *input_buffer, short *output_buffer, int num_samples, FIRFilter *filter)` that applies the FIR filter to a block of audio samples. This function will handle sample-by-sample convolution. Ensure it correctly handles buffer boundaries and filter history if needed (though simple FIR might not require extensive history between calls if buffers are processed independently).
    *   Status: Done
    *   Summary: Implemented `apply_fir_filter` in `MusicApp.c` with support for sample history (`fir_history`) for continuous filtering across buffers. Added `initialize_fir_history`.

3.  **Integrate Equalizer into `MusicApp.c`**:
    *   Add global variables to store the current FIR filter/equalizer mode and an array of available `FIRFilter` structures.
    *   Modify the main audio processing loop in `MusicApp.c`:
        *   After reading audio data into `buff` and before playback speed adjustment, convert samples to `short` if they aren't already (assuming 16-bit audio for FIR processing, which is common).
        *   Apply the selected FIR filter using `apply_fir_filter`.
        *   Convert processed samples back to `unsigned char *` if needed for ALSA.
    *   Status: Done
    *   Summary: Added `EQ_PRESETS`, `NUM_EQ_PRESETS`, and `current_eq_idx` globals. Integrated `apply_fir_filter` into the main loop, processing S16_LE audio. Handles memory for EQ buffer and passes filtered audio to speed adjustment or ALSA.

4.  **Add User Controls for Equalizer**:
    *   Assign new keyboard characters (e.g., '1', '2', '3') to switch between equalizer modes.
    *   Update the help message and `app_log` to inform the user about the new controls.
    *   Status: Done
    *   Summary: Added input handling for '1', '2', '3' to change `current_eq_idx` and re-initialize FIR history. Updated `app_log` message with new controls.

5.  **Testing and Refinement**:
    *   Test with various audio files and equalizer settings.
    *   Adjust FIR coefficients if necessary to achieve desired audio effects.
    *   Profile if performance issues arise, though a reasonably sized FIR filter should be manageable.
    *   Status: Pending User Action
    *   Summary: User needs to compile, test with audio, and potentially refine FIR coefficients in `const.h` for desired sound. The current coefficients are placeholders.

6.  **Update Documentation**:
    *   Update `README.md` to explain the equalizer feature, available modes, and how to control it.
    *   Status: Done
    *   Summary: Updated `README.md` with details on the equalizer feature, controls (1, 2, 3), and a note about the placeholder nature of the current FIR coefficients.
